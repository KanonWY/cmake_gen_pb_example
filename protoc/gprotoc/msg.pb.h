// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: msg.proto

#ifndef PROTOBUF_INCLUDED_msg_2eproto
#define PROTOBUF_INCLUDED_msg_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_msg_2eproto 

namespace protobuf_msg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_msg_2eproto
namespace EAST_TCP {
class MsgContent;
class MsgContentDefaultTypeInternal;
extern MsgContentDefaultTypeInternal _MsgContent_default_instance_;
class RequestContent;
class RequestContentDefaultTypeInternal;
extern RequestContentDefaultTypeInternal _RequestContent_default_instance_;
class ResponseContent;
class ResponseContentDefaultTypeInternal;
extern ResponseContentDefaultTypeInternal _ResponseContent_default_instance_;
class ResponseContent_NamespaceConfigMapEntry_DoNotUse;
class ResponseContent_NamespaceConfigMapEntry_DoNotUseDefaultTypeInternal;
extern ResponseContent_NamespaceConfigMapEntry_DoNotUseDefaultTypeInternal _ResponseContent_NamespaceConfigMapEntry_DoNotUse_default_instance_;
}  // namespace EAST_TCP
namespace google {
namespace protobuf {
template<> ::EAST_TCP::MsgContent* Arena::CreateMaybeMessage<::EAST_TCP::MsgContent>(Arena*);
template<> ::EAST_TCP::RequestContent* Arena::CreateMaybeMessage<::EAST_TCP::RequestContent>(Arena*);
template<> ::EAST_TCP::ResponseContent* Arena::CreateMaybeMessage<::EAST_TCP::ResponseContent>(Arena*);
template<> ::EAST_TCP::ResponseContent_NamespaceConfigMapEntry_DoNotUse* Arena::CreateMaybeMessage<::EAST_TCP::ResponseContent_NamespaceConfigMapEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace EAST_TCP {

enum CMD_TYPE {
  NULL_CMD = 0,
  REQUEST = 1,
  RESPONSE = 2,
  CMD_TYPE_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  CMD_TYPE_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool CMD_TYPE_IsValid(int value);
const CMD_TYPE CMD_TYPE_MIN = NULL_CMD;
const CMD_TYPE CMD_TYPE_MAX = RESPONSE;
const int CMD_TYPE_ARRAYSIZE = CMD_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* CMD_TYPE_descriptor();
inline const ::std::string& CMD_TYPE_Name(CMD_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    CMD_TYPE_descriptor(), value);
}
inline bool CMD_TYPE_Parse(
    const ::std::string& name, CMD_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CMD_TYPE>(
    CMD_TYPE_descriptor(), name, value);
}
// ===================================================================

class MsgContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EAST_TCP.MsgContent) */ {
 public:
  MsgContent();
  virtual ~MsgContent();

  MsgContent(const MsgContent& from);

  inline MsgContent& operator=(const MsgContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgContent(MsgContent&& from) noexcept
    : MsgContent() {
    *this = ::std::move(from);
  }

  inline MsgContent& operator=(MsgContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgContent* internal_default_instance() {
    return reinterpret_cast<const MsgContent*>(
               &_MsgContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MsgContent* other);
  friend void swap(MsgContent& a, MsgContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgContent* New() const final {
    return CreateMaybeMessage<MsgContent>(NULL);
  }

  MsgContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MsgContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MsgContent& from);
  void MergeFrom(const MsgContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MsgContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // bytes content = 3;
  void clear_content();
  static const int kContentFieldNumber = 3;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const void* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // .EAST_TCP.CMD_TYPE cmd = 2;
  void clear_cmd();
  static const int kCmdFieldNumber = 2;
  ::EAST_TCP::CMD_TYPE cmd() const;
  void set_cmd(::EAST_TCP::CMD_TYPE value);

  // @@protoc_insertion_point(class_scope:EAST_TCP.MsgContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  int cmd_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EAST_TCP.RequestContent) */ {
 public:
  RequestContent();
  virtual ~RequestContent();

  RequestContent(const RequestContent& from);

  inline RequestContent& operator=(const RequestContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestContent(RequestContent&& from) noexcept
    : RequestContent() {
    *this = ::std::move(from);
  }

  inline RequestContent& operator=(RequestContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestContent* internal_default_instance() {
    return reinterpret_cast<const RequestContent*>(
               &_RequestContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RequestContent* other);
  friend void swap(RequestContent& a, RequestContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestContent* New() const final {
    return CreateMaybeMessage<RequestContent>(NULL);
  }

  RequestContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestContent& from);
  void MergeFrom(const RequestContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string namespace_vec = 6;
  int namespace_vec_size() const;
  void clear_namespace_vec();
  static const int kNamespaceVecFieldNumber = 6;
  const ::std::string& namespace_vec(int index) const;
  ::std::string* mutable_namespace_vec(int index);
  void set_namespace_vec(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_namespace_vec(int index, ::std::string&& value);
  #endif
  void set_namespace_vec(int index, const char* value);
  void set_namespace_vec(int index, const char* value, size_t size);
  ::std::string* add_namespace_vec();
  void add_namespace_vec(const ::std::string& value);
  #if LANG_CXX11
  void add_namespace_vec(::std::string&& value);
  #endif
  void add_namespace_vec(const char* value);
  void add_namespace_vec(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& namespace_vec() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_namespace_vec();

  // string host_info = 3;
  void clear_host_info();
  static const int kHostInfoFieldNumber = 3;
  const ::std::string& host_info() const;
  void set_host_info(const ::std::string& value);
  #if LANG_CXX11
  void set_host_info(::std::string&& value);
  #endif
  void set_host_info(const char* value);
  void set_host_info(const char* value, size_t size);
  ::std::string* mutable_host_info();
  ::std::string* release_host_info();
  void set_allocated_host_info(::std::string* host_info);

  // string token = 4;
  void clear_token();
  static const int kTokenFieldNumber = 4;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // string appid = 5;
  void clear_appid();
  static const int kAppidFieldNumber = 5;
  const ::std::string& appid() const;
  void set_appid(const ::std::string& value);
  #if LANG_CXX11
  void set_appid(::std::string&& value);
  #endif
  void set_appid(const char* value);
  void set_appid(const char* value, size_t size);
  ::std::string* mutable_appid();
  ::std::string* release_appid();
  void set_allocated_appid(::std::string* appid);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 sequence = 2;
  void clear_sequence();
  static const int kSequenceFieldNumber = 2;
  ::google::protobuf::int64 sequence() const;
  void set_sequence(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:EAST_TCP.RequestContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> namespace_vec_;
  ::google::protobuf::internal::ArenaStringPtr host_info_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::google::protobuf::internal::ArenaStringPtr appid_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 sequence_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResponseContent_NamespaceConfigMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ResponseContent_NamespaceConfigMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ResponseContent_NamespaceConfigMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ResponseContent_NamespaceConfigMapEntry_DoNotUse();
  ResponseContent_NamespaceConfigMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ResponseContent_NamespaceConfigMapEntry_DoNotUse& other);
  static const ResponseContent_NamespaceConfigMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ResponseContent_NamespaceConfigMapEntry_DoNotUse*>(&_ResponseContent_NamespaceConfigMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ResponseContent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EAST_TCP.ResponseContent) */ {
 public:
  ResponseContent();
  virtual ~ResponseContent();

  ResponseContent(const ResponseContent& from);

  inline ResponseContent& operator=(const ResponseContent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResponseContent(ResponseContent&& from) noexcept
    : ResponseContent() {
    *this = ::std::move(from);
  }

  inline ResponseContent& operator=(ResponseContent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseContent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResponseContent* internal_default_instance() {
    return reinterpret_cast<const ResponseContent*>(
               &_ResponseContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ResponseContent* other);
  friend void swap(ResponseContent& a, ResponseContent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResponseContent* New() const final {
    return CreateMaybeMessage<ResponseContent>(NULL);
  }

  ResponseContent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResponseContent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResponseContent& from);
  void MergeFrom(const ResponseContent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResponseContent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> namespace_config_map = 4;
  int namespace_config_map_size() const;
  void clear_namespace_config_map();
  static const int kNamespaceConfigMapFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      namespace_config_map() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_namespace_config_map();

  // string appid = 3;
  void clear_appid();
  static const int kAppidFieldNumber = 3;
  const ::std::string& appid() const;
  void set_appid(const ::std::string& value);
  #if LANG_CXX11
  void set_appid(::std::string&& value);
  #endif
  void set_appid(const char* value);
  void set_appid(const char* value, size_t size);
  ::std::string* mutable_appid();
  ::std::string* release_appid();
  void set_allocated_appid(::std::string* appid);

  // int64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // int64 ack = 2;
  void clear_ack();
  static const int kAckFieldNumber = 2;
  ::google::protobuf::int64 ack() const;
  void set_ack(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:EAST_TCP.ResponseContent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      ResponseContent_NamespaceConfigMapEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > namespace_config_map_;
  ::google::protobuf::internal::ArenaStringPtr appid_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::int64 ack_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_msg_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MsgContent

// string version = 1;
inline void MsgContent::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MsgContent::version() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.MsgContent.version)
  return version_.GetNoArena();
}
inline void MsgContent::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EAST_TCP.MsgContent.version)
}
#if LANG_CXX11
inline void MsgContent::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EAST_TCP.MsgContent.version)
}
#endif
inline void MsgContent::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EAST_TCP.MsgContent.version)
}
inline void MsgContent::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EAST_TCP.MsgContent.version)
}
inline ::std::string* MsgContent::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:EAST_TCP.MsgContent.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgContent::release_version() {
  // @@protoc_insertion_point(field_release:EAST_TCP.MsgContent.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgContent::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:EAST_TCP.MsgContent.version)
}

// .EAST_TCP.CMD_TYPE cmd = 2;
inline void MsgContent::clear_cmd() {
  cmd_ = 0;
}
inline ::EAST_TCP::CMD_TYPE MsgContent::cmd() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.MsgContent.cmd)
  return static_cast< ::EAST_TCP::CMD_TYPE >(cmd_);
}
inline void MsgContent::set_cmd(::EAST_TCP::CMD_TYPE value) {
  
  cmd_ = value;
  // @@protoc_insertion_point(field_set:EAST_TCP.MsgContent.cmd)
}

// bytes content = 3;
inline void MsgContent::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MsgContent::content() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.MsgContent.content)
  return content_.GetNoArena();
}
inline void MsgContent::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EAST_TCP.MsgContent.content)
}
#if LANG_CXX11
inline void MsgContent::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EAST_TCP.MsgContent.content)
}
#endif
inline void MsgContent::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EAST_TCP.MsgContent.content)
}
inline void MsgContent::set_content(const void* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EAST_TCP.MsgContent.content)
}
inline ::std::string* MsgContent::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:EAST_TCP.MsgContent.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgContent::release_content() {
  // @@protoc_insertion_point(field_release:EAST_TCP.MsgContent.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgContent::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:EAST_TCP.MsgContent.content)
}

// -------------------------------------------------------------------

// RequestContent

// int64 timestamp = 1;
inline void RequestContent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestContent::timestamp() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.RequestContent.timestamp)
  return timestamp_;
}
inline void RequestContent::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:EAST_TCP.RequestContent.timestamp)
}

// int64 sequence = 2;
inline void RequestContent::clear_sequence() {
  sequence_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RequestContent::sequence() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.RequestContent.sequence)
  return sequence_;
}
inline void RequestContent::set_sequence(::google::protobuf::int64 value) {
  
  sequence_ = value;
  // @@protoc_insertion_point(field_set:EAST_TCP.RequestContent.sequence)
}

// string host_info = 3;
inline void RequestContent::clear_host_info() {
  host_info_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestContent::host_info() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.RequestContent.host_info)
  return host_info_.GetNoArena();
}
inline void RequestContent::set_host_info(const ::std::string& value) {
  
  host_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EAST_TCP.RequestContent.host_info)
}
#if LANG_CXX11
inline void RequestContent::set_host_info(::std::string&& value) {
  
  host_info_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EAST_TCP.RequestContent.host_info)
}
#endif
inline void RequestContent::set_host_info(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  host_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EAST_TCP.RequestContent.host_info)
}
inline void RequestContent::set_host_info(const char* value, size_t size) {
  
  host_info_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EAST_TCP.RequestContent.host_info)
}
inline ::std::string* RequestContent::mutable_host_info() {
  
  // @@protoc_insertion_point(field_mutable:EAST_TCP.RequestContent.host_info)
  return host_info_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestContent::release_host_info() {
  // @@protoc_insertion_point(field_release:EAST_TCP.RequestContent.host_info)
  
  return host_info_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestContent::set_allocated_host_info(::std::string* host_info) {
  if (host_info != NULL) {
    
  } else {
    
  }
  host_info_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_info);
  // @@protoc_insertion_point(field_set_allocated:EAST_TCP.RequestContent.host_info)
}

// string token = 4;
inline void RequestContent::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestContent::token() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.RequestContent.token)
  return token_.GetNoArena();
}
inline void RequestContent::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EAST_TCP.RequestContent.token)
}
#if LANG_CXX11
inline void RequestContent::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EAST_TCP.RequestContent.token)
}
#endif
inline void RequestContent::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EAST_TCP.RequestContent.token)
}
inline void RequestContent::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EAST_TCP.RequestContent.token)
}
inline ::std::string* RequestContent::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:EAST_TCP.RequestContent.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestContent::release_token() {
  // @@protoc_insertion_point(field_release:EAST_TCP.RequestContent.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestContent::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:EAST_TCP.RequestContent.token)
}

// string appid = 5;
inline void RequestContent::clear_appid() {
  appid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestContent::appid() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.RequestContent.appid)
  return appid_.GetNoArena();
}
inline void RequestContent::set_appid(const ::std::string& value) {
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EAST_TCP.RequestContent.appid)
}
#if LANG_CXX11
inline void RequestContent::set_appid(::std::string&& value) {
  
  appid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EAST_TCP.RequestContent.appid)
}
#endif
inline void RequestContent::set_appid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EAST_TCP.RequestContent.appid)
}
inline void RequestContent::set_appid(const char* value, size_t size) {
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EAST_TCP.RequestContent.appid)
}
inline ::std::string* RequestContent::mutable_appid() {
  
  // @@protoc_insertion_point(field_mutable:EAST_TCP.RequestContent.appid)
  return appid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestContent::release_appid() {
  // @@protoc_insertion_point(field_release:EAST_TCP.RequestContent.appid)
  
  return appid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestContent::set_allocated_appid(::std::string* appid) {
  if (appid != NULL) {
    
  } else {
    
  }
  appid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), appid);
  // @@protoc_insertion_point(field_set_allocated:EAST_TCP.RequestContent.appid)
}

// repeated string namespace_vec = 6;
inline int RequestContent::namespace_vec_size() const {
  return namespace_vec_.size();
}
inline void RequestContent::clear_namespace_vec() {
  namespace_vec_.Clear();
}
inline const ::std::string& RequestContent::namespace_vec(int index) const {
  // @@protoc_insertion_point(field_get:EAST_TCP.RequestContent.namespace_vec)
  return namespace_vec_.Get(index);
}
inline ::std::string* RequestContent::mutable_namespace_vec(int index) {
  // @@protoc_insertion_point(field_mutable:EAST_TCP.RequestContent.namespace_vec)
  return namespace_vec_.Mutable(index);
}
inline void RequestContent::set_namespace_vec(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:EAST_TCP.RequestContent.namespace_vec)
  namespace_vec_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RequestContent::set_namespace_vec(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:EAST_TCP.RequestContent.namespace_vec)
  namespace_vec_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RequestContent::set_namespace_vec(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  namespace_vec_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:EAST_TCP.RequestContent.namespace_vec)
}
inline void RequestContent::set_namespace_vec(int index, const char* value, size_t size) {
  namespace_vec_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:EAST_TCP.RequestContent.namespace_vec)
}
inline ::std::string* RequestContent::add_namespace_vec() {
  // @@protoc_insertion_point(field_add_mutable:EAST_TCP.RequestContent.namespace_vec)
  return namespace_vec_.Add();
}
inline void RequestContent::add_namespace_vec(const ::std::string& value) {
  namespace_vec_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:EAST_TCP.RequestContent.namespace_vec)
}
#if LANG_CXX11
inline void RequestContent::add_namespace_vec(::std::string&& value) {
  namespace_vec_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:EAST_TCP.RequestContent.namespace_vec)
}
#endif
inline void RequestContent::add_namespace_vec(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  namespace_vec_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:EAST_TCP.RequestContent.namespace_vec)
}
inline void RequestContent::add_namespace_vec(const char* value, size_t size) {
  namespace_vec_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:EAST_TCP.RequestContent.namespace_vec)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RequestContent::namespace_vec() const {
  // @@protoc_insertion_point(field_list:EAST_TCP.RequestContent.namespace_vec)
  return namespace_vec_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RequestContent::mutable_namespace_vec() {
  // @@protoc_insertion_point(field_mutable_list:EAST_TCP.RequestContent.namespace_vec)
  return &namespace_vec_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ResponseContent

// int64 timestamp = 1;
inline void ResponseContent::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseContent::timestamp() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.ResponseContent.timestamp)
  return timestamp_;
}
inline void ResponseContent::set_timestamp(::google::protobuf::int64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:EAST_TCP.ResponseContent.timestamp)
}

// int64 ack = 2;
inline void ResponseContent::clear_ack() {
  ack_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ResponseContent::ack() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.ResponseContent.ack)
  return ack_;
}
inline void ResponseContent::set_ack(::google::protobuf::int64 value) {
  
  ack_ = value;
  // @@protoc_insertion_point(field_set:EAST_TCP.ResponseContent.ack)
}

// string appid = 3;
inline void ResponseContent::clear_appid() {
  appid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ResponseContent::appid() const {
  // @@protoc_insertion_point(field_get:EAST_TCP.ResponseContent.appid)
  return appid_.GetNoArena();
}
inline void ResponseContent::set_appid(const ::std::string& value) {
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EAST_TCP.ResponseContent.appid)
}
#if LANG_CXX11
inline void ResponseContent::set_appid(::std::string&& value) {
  
  appid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EAST_TCP.ResponseContent.appid)
}
#endif
inline void ResponseContent::set_appid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EAST_TCP.ResponseContent.appid)
}
inline void ResponseContent::set_appid(const char* value, size_t size) {
  
  appid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EAST_TCP.ResponseContent.appid)
}
inline ::std::string* ResponseContent::mutable_appid() {
  
  // @@protoc_insertion_point(field_mutable:EAST_TCP.ResponseContent.appid)
  return appid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResponseContent::release_appid() {
  // @@protoc_insertion_point(field_release:EAST_TCP.ResponseContent.appid)
  
  return appid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResponseContent::set_allocated_appid(::std::string* appid) {
  if (appid != NULL) {
    
  } else {
    
  }
  appid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), appid);
  // @@protoc_insertion_point(field_set_allocated:EAST_TCP.ResponseContent.appid)
}

// map<string, string> namespace_config_map = 4;
inline int ResponseContent::namespace_config_map_size() const {
  return namespace_config_map_.size();
}
inline void ResponseContent::clear_namespace_config_map() {
  namespace_config_map_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
ResponseContent::namespace_config_map() const {
  // @@protoc_insertion_point(field_map:EAST_TCP.ResponseContent.namespace_config_map)
  return namespace_config_map_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
ResponseContent::mutable_namespace_config_map() {
  // @@protoc_insertion_point(field_mutable_map:EAST_TCP.ResponseContent.namespace_config_map)
  return namespace_config_map_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace EAST_TCP

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::EAST_TCP::CMD_TYPE> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAST_TCP::CMD_TYPE>() {
  return ::EAST_TCP::CMD_TYPE_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_msg_2eproto
